import re
import collections
import inspect
import codecs
import string
import datetime
import itertools
import os
import errno
import stat
import threading
import traceback
import sys
import time
import threading
from itertools import *
import functools
import random
from io import StringIO
import functools

#import logging
#import logging.handlers
#from collections import deque
#import calendar
#import markupsafe

def mklist (*args):
    """Returns args as a list.  Allows constructing lists using the arg list special * operator,
     which is convenient sometimes.  For example mklist (1,2,3,*[4,5,6]).  Note that the
    * expression can only appear at the end of the arg list - which
    is considerably less fun than it could be."""
    return args

def mktuple (*args):
    return tuple (args)
    
class Enum(object):
    """Base class for enums generated by the 'enum()' method
    """

    @classmethod
    def __label__ (cls, key, ifNot=None):
        """Turns a key into the corresponding label.  If the key is not found,
        the key itself is returned as a label.
        """
        return cls.__choices__.get (key, key) if key != ifNot else ''

    @classmethod
    def __indexof__ (cls, key, default=None):
        """Returns the index of a key within the enum.  If a default value is
        given that will be given rather than an attribute exception if the key
        is missing.
        """
        return cls.__keyToIndex__[key] if default is None else \
            cls.__keyToIndex__.get (key, default)

def enum(*enumKeyValuePairs, **enumMap):
    """Generates a unque enum type with the specified key/values.  Enum defs can
    be passed in as a map or a sequence of key/value pairs - the sequence of key
    value pairs should be used when the order of the enum values matters (you
    could also pass an OrderedDict for enumMap).
    """
    enums = collections.OrderedDict (enumKeyValuePairs)
    enums.update (enumMap)
    keyToIndex = {k:i for k, i in zip (enums.keys (), range(0, len(enums)))}
    members = collections.OrderedDict ([(k,k) for k,v in enums.items ()])
    #print 'ENUMS', enums
    members['__choices__'] = enums
    members['__items__'] = enums.items ()
    members['__keys__'] = enums.keys ()
    members['__keyToIndex__'] = keyToIndex
    return type('enum', (Enum,), members)

def kv(**kv):
    """A convenience? way of specifying a single key/value pair:
    kv(key=value) returns the tuple (key, value). For example:
    kv(name='Barry') is perhaps nicer than ('name', 'Barry')?
    """
    items = kv.items()
    if len(items) != 1:
        raise RuntimeError('Key value expr must have exactly one key/value pair')
    return items[0]

def writeFile(filename, content):
    f = open(filename, 'w')
    try:
        f.write (content)
    finally: 
        f.close ()


def readUTF8File(filename):
    f = codecs.open(filename, encoding='utf-8')
    try:
        return f.read ()
    finally: 
        f.close ()


def writeUTF8File(filename, content):
    f = codecs.open(filename, 'w', encoding='utf-8')
    try:
        f.write (content)
    finally: 
        f.close ()

def writeUTF8FileIfContentsChanged(filename, content):
    """Write a file if the content is different than what is presently
    on disk.  This avoids updating timestamps during re-gen processes if
    the content is unchanged.  (thereby avoiding cascading compiles/syncs/
    cache lossage etc when the last modified is used to check for changes)"""
    if not os.path.exists (filename) or content != readUTF8File (filename):
        writeUTF8File (filename, content)


def selectOptions(optionsHtml, valuesToSelect):
    """ We pre-generate and cache some large html <option> lists, and then
    at render time we want to mark certain values as selected.  This method
    textually replaces <option value='N'> with <option value='N' selected> for
    a list of N to transform the cached option list into one with some 
    pre-chosen selections.  Note that the format of the <option> string must
    exactly match the pattern above (same quotes, no extra spaces etc).
    """
    s = optionsHtml
    for v in valuesToSelect:
        s = s.replace ("<option value='{}'>".format (v), 
                       "<option value='{}' selected>".format (v))
    return s

def trimWithEllipses (s, maxLen=80):
    if not maxLen: return s
    return s if len (s) <= maxLen else s[:max (maxLen-4,0)]+u' ...'
    
def normalizeNewlines (s):
    """Normalizes mixed newline conventions to the UNIX standard.
    """
    withWindowsNewlinesNormalized = \
        string.replace (s, '\r\n', '\n')
    withStragglingMacNewlinesNormalized = \
        string.replace (withWindowsNewlinesNormalized, '\r', '\n')
    return withStragglingMacNewlinesNormalized

def stripOptSuffix (s, suffix):
    return s[:-len(suffix)] if s.endswith (suffix) else s

def stripOptPrefix (s, prefix):
    return s[len(prefix):] if s.startswith (prefix) else s

def test_strip():
    assert stripOptSuffix ('foo.html', '.html') == 'foo'
    assert stripOptSuffix ('foo_html', '.html') == 'foo_html'
    assert stripOptPrefix ('foo.html', 'foo') == '.html'
    assert stripOptPrefix ('foo_html', 'fob') == 'foo_html'

def lowerFirstLetter(s): return s[0:1].lower()+s[1:]

def upperFirstLetter(s): return s[0:1].upper()+s[1:]

def camelCaseToWords (s):
    """Transforms camel cased words into separate words.  For example
    'camelCaseToWords' would be translated to 'camel case to words'.
    Ideally, would do something fancy for acronyms, but not today.
    """
    return ''.join ([' '+c.lower() if c.isupper () else c for c in s]).strip ()

def test_camelCaseToWords():
    assert camelCaseToWords('camelCaseToWords') == 'camel case to words'

def englishToCamelCase (s):
    return englishToIdentifier (s, separator='', upcaseWords=True)

def test_englishToCamelCase():
    assert englishToCamelCase('the cat is red.') == 'TheCatIsRed'


def englishToUriSegment (s):
    return englishToIdentifier (s, separator='-')

def test_englishToUriSegment():
    assert englishToUriSegment('the cat is red.') == 'the-cat-is-red'

toRemoveRegex = re.compile (u"['()]")
nonAlphaRegex = re.compile (u"[^a-zA-Z0-9]")

def englishToIdentifier (s, separator='_', upcaseWords=False):
    # remove apostrophes and some other punctuation
    s = toRemoveRegex.sub ('', s)

    # then, replace all non-alphanumeric chars with space
    s = nonAlphaRegex.sub (' ', s)

    # split into words
    words = s.split ()
    
    # optionally upcase words
    if upcaseWords:
        words = [upperFirstLetter (w) for w in words]

    # then, join the words with the separator
    return separator.join (words)

    
def deref (v, path):
    return functools.reduce (derefStep, path.split ('.'), v)

def derefStep (v, name):
    if v is None:
        return None
    elif isinstance(v, list):
        return v[name]
    elif isinstance(v, dict):
        return v[name]
    else:
        return getattr (v, name)

def test_deref():
    assert (deref ({'name': 'David'}, 'name') == 'David')
    assert (deref ({'friend': {'name': 'David'}}, 'friend.name') == 'David')
    class Person (object): pass
    lesley = Person ()
    lesley.name = 'Lesley'
    lesley.hamster = None
    david = Person ()
    david.spouse = lesley
    assert (deref (david, 'spouse.name') == 'Lesley')
    assert (deref (david, 'spouse.hamster') == None)
    assert (deref (david, 'spouse.hamster.name') == None)
    
class CmpNoneAsHigh (object):
    """Used to wrap values in sort keys so that None can participate in the sort
    """
    def __init__ (self, value):
        self.value = value

    def __cmp__ (self, other):
        if self.value == other.value:
            return 0
        elif self.value == None:
            return 1
        elif other.value == None:
            return -1
        else:
            return cmp (self.value, other.value)

class CmpNoneAsLow (object):
    """Used to wrap values in sort keys so that None can participate in the sort
    """
    def __init__ (self, value):
        self.value = value

    def __cmp__ (self, other):
        if self.value == other.value:
            return 0
        elif self.value == None:
            return -1
        elif other.value == None:
            return 1
        else:
            return cmp (self.value, other.value)
        

class CmpFalseValueAsHigh (object):
    """Used to wrap values in sort keys so that false values (0, None, False etc) participate in 
    sorts by sorting high.
    """
    def __init__ (self, value):
        self.value = value

    def __cmp__ (self, other):
        if self.value == other.value:
            return 0
        elif not self.value and not other.value:
            return cmp (self.value, other.value)
        elif not self.value:
            return 1
        elif not other.value:
            return -1
        else:
            return cmp (self.value, other.value)

def findFiles (directory, filterFn=None, out=None):
    """Finds all files under the specified directory.
    Files and directories can optionally be filtered by filterFn.
    Returns a list containing a tuple for each file with (path, size, mtime).
    """
    if out is None: out = []
    for filename in os.listdir (directory):
        filepath = os.path.join (directory, filename)
        filestat = os.stat (filepath)
        if not filterFn or filterFn (filepath, filestat):
            if stat.S_ISDIR(filestat.st_mode):
                findFiles (filepath, filterFn, out)
            else:
                out.append ((filepath, filestat[stat.ST_SIZE], filestat[stat.ST_MTIME]))
    return out

class keydefaultdict(collections.defaultdict):
    """Subclass of defaultdict that passes the key to the factory function
       By: Jochen Ritzel 
       From: http://stackoverflow.com/questions/2912231/is-there-a-clever-way-to-pass-the-key-to-defaultdicts-default-factory
    """ 
    def __missing__(self, key):
        if self.default_factory is None:
            raise KeyError( key )
        else:
            ret = self[key] = self.default_factory(key)
            return ret


class PeriodicallyUpdatedValue(object):
    """A thread that periodically updates a value.
    """

    def __init__ (self, task, period, label=None):
        self.task = task
        self.period = period
        self.label = label
        self.lock = threading.RLock()
        self.lastAttemptTime = 0
        self.lastUpdatedTime = 0
        self.thread = None
        self.currentValue = None
        self.currentErrorMsg = None

    def run_ (self):
        verbose = False

        while True:
            if time.time () - self.lastAttemptTime > self.period:
                self.update ()
            # we use short sleeps + the lastAttemptTime mechanism rather than the
            # simpler longer sleeps because we thought the sleeping thead was
            # delaying cherrypy restart during development. (which turned out
            # not to be true)
            time.sleep (min (0.5, self.period))

    def update (self):
        self.lastAttemptTime = time.time ()
        try:
            updatedValue = self.task ()
            updatedErrorMsg = None
        except:
            updatedValue = None
            updatedErrorMsg = traceback.format_exc ()
        with self.lock:
            self.currentValue = updatedValue
            self.currentErrorMsg = updatedErrorMsg
            self.lastUpdatedTime = time.time ()

    def start (self):
        if self.thread:
            raise RuntimeError ('task already started')
        self.thread = threading.Thread (target = self.run_)
        self.thread.daemon = True
        self.thread.start ()

    def getFreshness (self):
        with self.lock:
            return time.time ()-self.lastUpdatedTime

    def getCurrentValue (self, allowStart=True, errorIfStale=False, forceRefresh=False):

        alreadyRefreshed = False

        with self.lock:
            if not self.thread:
                if not allowStart:
                    raise RuntimeError ('Thread is not running for updated value {}'.format (self.label))
                self.update ()
                alreadyRefreshed = True
                self.start ()
                
        if forceRefresh and not alreadyRefreshed:
            with self.lock:
                self.update ()

        with self.lock:
            if errorIfStale and time.time ()-self.lastUpdatedTime > 3*self.period:
                raise RuntimeError ('Updated value {} is too old'.format (self.label))

        if self.currentErrorMsg:
            raise RuntimeError (self.currentErrorMsg)
        else:
            return self.currentValue

def iscallable (f): return isinstance (f, collections.Callable)

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST:
            pass
        else: raise

def opthead(lst): return lst[0] if len(lst) else None

def opttail(lst): return lst[-1] if len(lst) else None

# class lazy:
# FROM: https://pypi.python.org/pypi/lazy
# BY: Stefan H. Holek (BSD)
# LOCAL ADDITION: invalidateAll

class lazy(object):
    """lazy descriptor

    Used as a decorator to create lazy attributes. Lazy attributes
    are evaluated on first use.
    """

    def __init__(self, func):
        self.__func = func
        functools.wraps(self.__func)(self)

    def __get__(self, inst, inst_cls):
        if inst is None:
            return self

        if not hasattr(inst, '__dict__'):
            raise AttributeError("'%s' object has no attribute '__dict__'" % (inst_cls.__name__,))

        name = self.__name__
        if name.startswith('__') and not name.endswith('__'):
            name = '_%s%s' % (inst_cls.__name__, name)

        value = self.__func(inst)
        inst.__dict__[name] = value

        # Local addition to support invalidateAll
        if not hasattr(inst, '__lazy_attr_names__'):
            inst.__lazy_attr_names__ = []
        inst.__lazy_attr_names__.append (name)
        
        return value

    @classmethod
    def invalidateAll(cls, inst):
        if not hasattr(inst, '__lazy_attr_names__'):
            return
        #print 'BEGIN invalidateAll', inst.__dict__
        for n in inst.__lazy_attr_names__:
            if n in inst.__dict__:
                del inst.__dict__[n]
        del inst.__dict__['__lazy_attr_names__']
        #print 'END invalidateAll', inst.__dict__
    
    @classmethod
    def invalidate(cls, inst, name):
        """Invalidate a lazy attribute.

        This obviously violates the lazy contract. A subclass of lazy
        may however have a contract where invalidation is appropriate.
        """
        inst_cls = inst.__class__

        if not hasattr(inst, '__dict__'):
            raise AttributeError("'%s' object has no attribute '__dict__'" % (inst_cls.__name__,))

        if name.startswith('__') and not name.endswith('__'):
            name = '_%s%s' % (inst_cls.__name__, name)

        if not isinstance(getattr(inst_cls, name), cls):
            raise AttributeError("'%s.%s' is not a %s attribute" % (inst_cls.__name__, name, cls.__name__))

        if name in inst.__dict__:
            del inst.__dict__[name]


class LazyTest(object):
    def __init__ (self, name):
        self.name = name

    @lazy
    def upperName (self):
        print('computed upper name')
        return self.name.upper ()

def lazyTest ():
    david = LazyTest ('David')
    lazy.invalidateAll (david)
    print('Computing upper name', david.upperName)
    print(david.__lazy_attr_names__)
    print('Should get cached upper name', david.upperName)
    print('Clearing lazy cache')
    lazy.invalidateAll (david)
    print('Computing upper name', david.upperName)
    print('Should get cached upper name', david.upperName)
    
    
if True and __name__ == "__main__":
    lazyTest ()

uniqueIdLock = threading.RLock()
nextUniqueId = 1

def generatePerProcessUniqueId ():
    global nextUniqueId
    with uniqueIdLock:
        id = nextUniqueId
        nextUniqueId += 1
        return id

# 'dameraulevenshtein' FROM: http://mwh.geek.nz/2009/04/26/python-damerau-levenshtein-distance/
# BY: Michael Homer
# License:  MIT

def dameraulevenshtein(seq1, seq2):
    """Calculate the Damerau-Levenshtein distance between sequences.

    This distance is the number of additions, deletions, substitutions,
    and transpositions needed to transform the first sequence into the
    second. Although generally used with strings, any sequences of
    comparable objects will work.

    Transpositions are exchanges of *consecutive* characters; all other
    operations are self-explanatory.

    This implementation is O(N*M) time and O(M) space, for N and M the
    lengths of the two sequences.

    >>> dameraulevenshtein('ba', 'abc')
    2
    >>> dameraulevenshtein('fee', 'deed')
    2

    It works with arbitrary sequences too:
    >>> dameraulevenshtein('abcd', ['b', 'a', 'c', 'd', 'e'])
    2
    """
    # codesnippet:D0DE4716-B6E6-4161-9219-2903BF8F547F
    # Conceptually, this is based on a len(seq1) + 1 * len(seq2) + 1 matrix.
    # However, only the current and two previous rows are needed at once,
    # so we only store those.
    oneago = None
    thisrow = range(1, len(seq2) + 1) + [0]
    for x in xrange(len(seq1)):
        # Python lists wrap around for negative indices, so put the
        # leftmost column at the *end* of the list. This matches with
        # the zero-indexed strings and saves extra calculation.
        twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]
        for y in xrange(len(seq2)):
            delcost = oneago[y] + 1
            addcost = thisrow[y - 1] + 1
            subcost = oneago[y - 1] + (seq1[x] != seq2[y])
            thisrow[y] = min(delcost, addcost, subcost)
            # This block deals with transpositions
            if (x > 0 and y > 0 and seq1[x] == seq2[y - 1]
                and seq1[x-1] == seq2[y] and seq1[x] != seq2[y]):
                thisrow[y] = min(thisrow[y], twoago[y - 2] + 1)
    return thisrow[len(seq2) - 1]

    
